## greedy algorithm(탐욕 알고리즘)

그리디 알고리즘은 동적 프로그래밍 사용시 지나치게 많은 일을 한다는 것에서 착안하여 고안된 알고리즘입니다.
동적 프로그래밍을 대체하는 것은 아니고 같이 쓰이며 서로 보완하는 개념.

그리디 알고리즘은 탐욕 알고리즘, 욕심쟁이 알고리즘이라고도 불리는데, 미래를 생각하지 않고 각 단계에서 가장 최선의 선택을 하는 기법. 각 단계에서 최선의 선택을 한 것이 전체적으로도 최선이길 바란다.


물론 모든 경우에서 그리디 알고리즘이 통하는건 아님. 
그리디 알고리즘이 통하는 문제 중 활동 선택 문제와 분할 가능 배낭 문제를 알아본다.


### 활동 선택 문제
활동 선택 문제는 쉽게 말하면 한 강의실에서 여러 개의 수업을 하려고 할 때 한 번에 가장 많은 수업을 할 수 있는 경우를 고르는 것.

예를 들어

i   1  2  3  4  5  6  7  8  9
si  1  2  4  1  5  8  9  11 13
fi  3  5  7  8  9  10 11 14 16

si와 fi 는 시작, 종료시간  같은 강의실을 이용해야 하므로 i1 i4는 동시에 선택할 수 없다.
i1 i2 도 시간이 겹치니깐 선택할 수 없다. 하지만 i1 i3는 안 겹치니깐 선택할 수 있다.

결과적으로 보면 i1 i3 i6 i8이나 i1 i3 i7 i9를 고르게하면 정답. 

동적프로그래밍으로도 할 수 있지만 비효율적.
그리디 알고리즘으로 더 효율적으로 풀 수 있음.
직관적으로 생각하면, 최적의 해를 구하기 위해서는 첫 번째 활동이 최대한 일찍 끝나면 된다.
그래야 다른 활동들을 더 많이 선택할 수 있기 때문에.
위의 경우에서는 첫 선택으로 가장 빨리 끝나는 A1을 골라야 한다.
i1을 골랐다면 i2, i4는 고를 수 없고, 그 다음 선택은 다음으로 일찍 끝나는 i3
그다음은 i6, 마지막은 i8이 되어 최종적으로 i1, i3, i6, i8이 된다.


js 코드 

    var activity = [[1,1,3], [2,2,5], [3,4,7], [4,1,8], [5,5,9], [6,8,10], [7,9,11], [8,11,14], [9,13,16];
    function activitySelection(act) {
      var result = [];
      var sorted = act.sort(function(prev, cur) {
        return prev[2] - cur[2]; // 끝나는 시간 순으로 정렬
      });
      var last = 0;
      sorted.forEach(function(item) {
        if (last < item[1]) { // 조건 만족 시 결과 집합에 추가
          last = item[2];
          result.push(item);
        }
      });
      return result.map(function(r) {
        return r[0]; // map을 한 이유는 그냥 몇 번째 행동이 선택되었는지 보여주기 위함.
      });
    }
    activitySelection(activity); // [1, 3, 6, 8]

일단 끝나는 시간 순으로 정렬한 후, 반복문을 돌며 집합의 끝나는 시간이 다음 해동의 시작 시간 보다 작은 경우
집합에 추가하면 된다.


### 분한 가능 배낭 문제

 동적 프로그래밍에서는 무게에 따라 물건을 넣거나 넣지 못하는 배낭 문제(0/1)문제를 풀 수 있다.
 그리디의 배낭 문제는 같은 배낭이지만 물건이 무거울 경우 쪼개서 넣을수 있다.
 즉 무게가 초과할 거 같으면 물건을 쪼개서 일부만 넣을 수 있다.

 물건을 쪼갤 수 있다는 가정 하에서는 무게대비 가치가 높은 것들을 먼저 넣는게 제일 좋다.

 
 i         1      2     3

 vi       60    100    120         가치
 wi       10    20      30         무게
 vi/wi    6     5        4         무게 대비 가치

 js 코드

    var test = [[1,60,10], [2,100,20], [3,120,30]];
    function fractionalKnapsack(item, w) {   // 아이템들과 최대 무게를 받아서
      var sorted = item.sort(function(prev, cur) {
        return cur[1] / cur[2] - prev[1] / prev[2]; // 무게 대비 가치 순으로 정렬
      });
      var limit = w;      // 무게를 뺄거임.
      var result = 0;    // 가치를 더할거임
      for (var i = 0; i < sorted.length; i++) {
        var cur = sorted[i];
        if (limit > 0) {
          if (limit >= cur[2]) { // 물건 무게가 제한 이하일 경우
            limit -= cur[2];
            result += cur[1]; 
          } else { // 물건 무게가 제한 초과일 경우
            result += cur[1] / cur[2] * limit; // 잘라서 넣음   무게 대비 가치는 1개의 무개일 때 가치니깐 limit 만큼 넣을 수 있다.
            limit = 0;  // limit는 이제 0이 되고 끝.
          }
        } else {
          break;
        }
      }
      return result;
    }
    fractionalKnapsack(test, 50); // 240