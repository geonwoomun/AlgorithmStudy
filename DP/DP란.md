# Dynamic Programming (DP)

Dynamic Programming(이하 DP)는 우리말로 동적 프로그래밍이라고 한다.


## 동적 프로그래밍의 기초
  최적화 기법 중 하나로 재귀(recursion)를 이용하여 최적화 솔루션을 얻어내는 방식을 사용한다.
  동적 프로그래밍으로 풀 수 있는 가장 유명한 문제로 배낭 문제를 들 수 있다.
  
  동적 프로그래밍은 이름이 조금 이상하다고도 볼 수 있따. 프로그래밍은 컴퓨터 프로그래밍이라는 뜻이 아니라 테이블을 만든다는 뜻이다. 그리고 전혀 다이나믹하지도 않다. 그래서 어떤 서울대 교수님은 동적 프로그래밍을 대신해 기억하기 프로그래밍이라는 용어를 쓰기도 한다.

  재귀 호출 시, 반복적으로 계산되는 것들의 계산 횟수를 줄이기 위해 이전에 계산했던 값을 저장해두었다가 나중에 재사용하는 방법. 메모이제이션이 동적 프로그래밍 중 하나이다.
  
  알고리즘을 짤 때 분할정복 기법을 사용하는 경우가 많다. 큰 문제를 한 번에 해결하기 힘들 때 작은 여러개의 문제로 나누어서 푸는 기법인데, 작은 문제들을 풀다보면 같은 문제들을 반복해서 푸는 경우가 생긴다. 그 문제들을 매번 재계산하지 않고 값을 저장해두었다가 재사용하는 기법이 동적 프로그래밍이다.

  동적 프로그래밍의 대표적인 세가지 문제를 풀어볼것이다!! 막대기 자르기 문제, 최장 공통 부분 수열 문제, 그리고 0/1 배낭 문제...


### 막대기 자르기

  일단 막대기 부터 잘라본다. 하나의 긴 막대기가 있는데 막대기 조각마다 가격이 다르다. 막대기를 적절하게 잘라서 가장 가격이 높게 만들어야 한다.

  길이(i) 0 1 2 3 4 5 6 7 8 9 10
  가격(Pi) 0 1 5 8 9 10 17 17 20 24 30

  예를 들면 길이가 4인 막대기를 자를 때 얻을 수 있는 최대 가격은, 길이를 2인 막대기 두 개로 나누어서 가격을 5+5 = 10으로 만드는 겁니다. 길이가 6인 막대는 자르지 않고 그냥 팔았을 때 최대 17의 가격을 얻을 수 있다.

  이 문제는 그냥 풀기엔 좀 복잡하게 보이지만 동적 프로그래밍을 사용하면 간단하게 풀 수 있다.

  길이가 n인 막대기의 최대 가격을 Rn이라고 했을 때, Rn = max(Pi + Rn-i)(i는 1부터 n)로 나타낼 수 있다. max는 여러 값 중의 최대값을 의미한다. 예를 들면 아까 길이가 4인 막대기의 최대 가격은 R4 = max(P1 + R3, P2+R2, P3+R1 + P4+R0)이다.

  P1 P2 P3는 이미 주어져 있다 그래서 R1,R2,R3를 구해야하는데
  R1은 Rn = max(Pi = Rn-i) 식에서 max(Pi + R0)이므로 1이다.
  R2는 max(P1+R1, P2 + R0)이라 max(2,5) = 5 이다.
  R3는 max(P1 + R2, P2 + R1, P3 + R0)라서 max(6,6,8)이다.
  R4는 위의 값들로부터 max(9,10,9,9) = 10임을 알 수 있다.

  위의 과정에서 R1, R2, R3는 계속 나온다. 이값들을 저장해 두고 재사용하면 일일히 계산하지 않아도 된다. 바로 여기서 Top-down으로 불리는 메모이제이션을 사용할 수도 있고, Bottom-up이라 불리는 상향식 계산법을 사용할 수도 있다.

  상향식 계산법이 성능이 더 좋은 경우가 많으므로 상향식 계산법을 사용해보도록 한다.

  js

    var = p [0,1,5,8,9,10,17,17,20,24,30]; // 맏개의 길이
    function cutRod(p, n) {
        var r = [0];
        for (var j = 1; j <=n; j++){
            q = -1;
            for (var i = 1; i <= j; i ++){
                q = Math.max(q, p[i] + r[j - i]);
            }
            r[j] = q;
        }
        return r[n];
    }

    cutRod(p,2); // 5
    cutRod(p,3); // 8
    cutRod(p,4); // 10
    cutRod(p, 7); // 18

  r이 바로 이전에 계산한 값들을 저장하는 부분이다. 안의 반복문은 r[1]부터 r[j]를 구하는 부분이다. q는 각 길이에 대한 최대 가격 Ri을 의미. 바깥의 반복문은 구했떤 r[1] ~ r[j]를 활용하여 Rn의 최대값을 도출하고 있다.
